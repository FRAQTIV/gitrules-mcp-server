import { GitRulesPolicyMarkdownInputSchema, GitRulesPolicyMarkdownOutputSchema } from '../types/schemas.js';
import { gitRulesPolicyTool } from './gitPolicy.js';

function toMarkdown(data: any): string {
  const lines: string[] = [];
  lines.push('# Git Rules & Workflow Policy');
  const policy = data.git_rules_and_pull_request_policy;
  if (policy?.branch_model) {
    lines.push('## Branch Model');
    for (const [name, info] of Object.entries<any>(policy.branch_model)) {
      lines.push(`### ${name}`);
      for (const [k, v] of Object.entries(info)) {
        lines.push(`- **${k}**: ${Array.isArray(v)? v.join(', ') : v}`);
      }
    }
  }
  if (policy?.mandatory_pull_requests?.rules) {
    lines.push('## Mandatory Pull Requests');
    for (const r of policy.mandatory_pull_requests.rules) lines.push(`- ${r}`);
  }
  const llm = (data.git_workflow_rules_for_llm_assistants);
  if (llm?.branch_structure) {
    lines.push('## Branch Guidance for Assistants');
    for (const [n, info] of Object.entries<any>(llm.branch_structure)) {
      lines.push(`### ${n}`);
      for (const [k,v] of Object.entries(info)) lines.push(`- **${k}**: ${v}`);
    }
  }
  lines.push('\n_Generated by git.rules.policy.markdown tool_');
  return lines.join('\n');
}

export async function gitRulesPolicyMarkdownTool() {
  const base = await gitRulesPolicyTool();
  const md = toMarkdown(base.data);
  return { api_version: '1.1.0', human: md, data: { markdown: md } };
}

export const gitRulesPolicyMarkdownDef = {
  name: 'git.rules.policy.markdown',
  stability: 'experimental' as const,
  description: 'Markdown summary of branching and PR policy',
  inputSchema: GitRulesPolicyMarkdownInputSchema,
  outputSchema: GitRulesPolicyMarkdownOutputSchema,
  handler: gitRulesPolicyMarkdownTool
};
